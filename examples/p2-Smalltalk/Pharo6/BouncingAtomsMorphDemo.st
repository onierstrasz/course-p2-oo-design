SystemOrganization addCategory: #BouncingAtomsMorphDemo!EllipseMorph subclass: #AtomMorph	instanceVariableNames: 'velocity'	classVariableNames: ''	poolDictionaries: ''	category: 'BouncingAtomsMorphDemo'!!AtomMorph commentStamp: 'tbn 11/25/2004 09:06' prior: 0!AtomMorph represents an atom used in the simulation ofan ideal gas. It's container is typically a BouncingAtomsMorph.Try:	BouncingAtomsMorph  new openInWorldto open the gas simulation or:	AtomMorph exampleto open an instance in the current world!!AtomMorph class methodsFor: 'examples' stamp: 'tbn 11/25/2004 09:03'!example	"	AtomMorph example	"	|a|	a := AtomMorph new openInWorld. 	a color: Color random. 	[1000 timesRepeat:  [a bounceIn: World bounds.  (Delay forMilliseconds: 50) wait]. 	 a delete] fork.! !!AtomMorph class methodsFor: 'new-morph participation' stamp: 'di 6/22/97 09:07'!includeInNewMorphMenu	"Not to be instantiated from the menu"	^ false! !!AtomMorph methodsFor: 'private' stamp: 'jm 8/10/1998 17:40'!bounceIn: aRect	"Move this atom one step along its velocity vector and make it bounce if it goes outside the given rectangle. Return true if it is bounced."	| p vx vy px py bounced |	p := self position.	vx := velocity x.		vy := velocity y.	px := p x + vx.		py := p y + vy.	bounced := false.	px > aRect right ifTrue: [		px := aRect right - (px - aRect right).		vx := velocity x negated.		bounced := true].	py > aRect bottom ifTrue: [		py :=  aRect bottom - (py - aRect bottom).		vy := velocity y negated.		bounced := true].	px < aRect left ifTrue: [		px := aRect left - (px - aRect left).		vx := velocity x negated.		bounced := true].	py < aRect top ifTrue: [		py :=  aRect top - (py - aRect top).		vy := velocity y negated.		bounced := true].	self position: px @ py.	bounced ifTrue: [self velocity: vx @ vy].	^ bounced! !!AtomMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:13'!defaultBorderWidth"answer the default border width for the receiver"	^ 0! !!AtomMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:13'!defaultColor"answer the default color/fill style for the receiver"	^ Color blue! !!AtomMorph methodsFor: 'drawing' stamp: ''!drawOn: aCanvas	"Note: Set 'drawAsRect' to true to make the atoms draw faster. When testing the speed of other aspects of Morphic, such as its damage handling efficiency for large numbers of atoms, it is useful to make drawing faster."	| drawAsRect |	drawAsRect := false.  "rectangles are faster to draw"	drawAsRect		ifTrue: [aCanvas fillRectangle: self bounds color: color]		ifFalse: [super drawOn: aCanvas].! !!AtomMorph methodsFor: 'accessing' stamp: ''!infected	^ color = Color red! !!AtomMorph methodsFor: 'accessing' stamp: ''!infected: aBoolean	aBoolean		ifTrue: [self color: Color red]		ifFalse: [self color: Color blue].! !!AtomMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:13'!initialize	"Make a new atom with a random position and velocity."	super initialize.""	self extent: 8 @ 7.		self		randomPositionIn: (0 @ 0 corner: 300 @ 300)		maxVelocity: 10! !!AtomMorph methodsFor: 'initialization' stamp: 'RAA 12/15/2000 07:32'!randomPositionIn: aRectangle maxVelocity: maxVelocity	"Give this atom a random position and velocity."	| origin extent |	origin := aRectangle origin.	extent := (aRectangle extent - self bounds extent) rounded.	self position:		(origin x + extent x atRandom) @		(origin y + extent y atRandom).	velocity :=		(maxVelocity - (2 * maxVelocity) atRandom) @		(maxVelocity - (2 * maxVelocity) atRandom).! !!AtomMorph methodsFor: 'accessing' stamp: ''!velocity	^ velocity! !!AtomMorph methodsFor: 'accessing' stamp: ''!velocity: newVelocity	velocity := newVelocity.! !Morph subclass: #BouncingAtomsMorph	instanceVariableNames: 'damageReported infectionHistory transmitInfection recentTemperatures temperature'	classVariableNames: ''	poolDictionaries: ''	category: 'BouncingAtomsMorphDemo'!!BouncingAtomsMorph commentStamp: '<historical>' prior: 0!This morph shows how an ideal gas simulation might work. When it gets step messages, it makes all its atom submorphs move along their velocity vectors, bouncing when they hit a wall. It also exercises the Morphic damage reporting and display architecture. Here are some things to try:  1. Resize this morph as the atoms bounce around.  2. In an inspector on this morph, evaluate "self addAtoms: 10."  3. Try setting quickRedraw to false in invalidRect:. This gives the     default damage reporting and incremental redraw. Try it for     100 atoms.  4. In the drawOn: method of AtomMorph, change drawAsRect to true.  5. Create a HeaterCoolerMorph and embed it in the simulation. Extract	it and use an inspector on it to evaluate "self velocityDelta: -5", then     re-embed it. Note the effect on atoms passing over it.!!BouncingAtomsMorph class methodsFor: 'parts bin' stamp: 'sw 8/2/2001 01:21'!descriptionForPartsBin	^ self partName:	'BouncingAtoms'		categories:		#('Demo')		documentation:	'The original, intensively-optimized bouncing-atoms simulation by John Maloney'! !!BouncingAtomsMorph class methodsFor: 'initialization' stamp: 'asm 4/10/2003 12:57'!initialize	self registerInFlapsRegistry.	! !!BouncingAtomsMorph class methodsFor: 'initialization' stamp: 'asm 4/10/2003 12:58'!registerInFlapsRegistry	"Register the receiver in the system's flaps registry"	self environment		at: #Flaps		ifPresent: [:cl | cl registerQuad: #(BouncingAtomsMorph	new	'Bouncing Atoms'	'Atoms, mate')						forFlapNamed: 'Widgets']! !!BouncingAtomsMorph class methodsFor: 'initialization' stamp: 'asm 4/11/2003 12:32'!unload	"Unload the receiver from global registries"	self environment at: #Flaps ifPresent: [:cl |	cl unregisterQuadsWithReceiver: self] ! !!BouncingAtomsMorph methodsFor: 'other' stamp: 'jm 6/28/1998 18:10'!addAtoms: n	"Add a bunch of new atoms."	| a |	n timesRepeat: [		a := AtomMorph new.		a randomPositionIn: bounds maxVelocity: 10.		self addMorph: a].	self stopStepping.! !!BouncingAtomsMorph methodsFor: 'menu' stamp: 'dgd 8/30/2003 21:15'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'startInfection' translated action: #startInfection.	aCustomMenu add: 'set atom count' translated action: #setAtomCount.	aCustomMenu add: 'show infection history' translated action: #showInfectionHistory:.! !!BouncingAtomsMorph methodsFor: 'submorphs-add/remove' stamp: ''!addMorphFront: aMorph	"Called by the 'embed' meta action. We want non-atoms to go to the back."	"Note: A user would not be expected to write this method. However, a sufficiently advanced user (e.g, an e-toy author) might do something equivalent by overridding the drag-n-drop messages when they are implemented."	(aMorph isMemberOf: AtomMorph)		ifTrue: [super addMorphFront: aMorph]		ifFalse: [super addMorphBack: aMorph].! !!BouncingAtomsMorph methodsFor: 'drawing' stamp: 'di 1/4/1999 20:22'!areasRemainingToFill: aRectangle	color isTranslucent		ifTrue: [^ Array with: aRectangle]		ifFalse: [^ aRectangle areasOutside: self bounds]! !!BouncingAtomsMorph methodsFor: 'other' stamp: 'aoy 2/15/2003 21:38'!collisionPairs	"Return a list of pairs of colliding atoms, which are assumed to becircles of known radius. This version uses the morph's positions--i.e.the top-left of their bounds rectangles--rather than their centers."	| count sortedAtoms radius twoRadii radiiSquared collisions p1 continue j p2 distSquared m1 m2 |	count := submorphs size.	sortedAtoms := submorphs 				asSortedCollection: [:mt1 :mt2 | mt1 position x < mt2 position x].	radius := 8.	twoRadii := 2 * radius.	radiiSquared := radius squared * 2.	collisions := OrderedCollection new.	1 to: count - 1		do: 			[:i | 			m1 := sortedAtoms at: i.			p1 := m1 position.			continue := (j := i + 1) <= count.			[continue] whileTrue: 					[m2 := sortedAtoms at: j.					p2 := m2 position.					continue := p2 x - p1 x <= twoRadii  								ifTrue: 									[distSquared := (p1 x - p2 x) squared + (p1 y - p2 y) squared.									distSquared < radiiSquared 										ifTrue: [collisions add: (Array with: m1 with: m2)].									(j := j + 1) <= count]								ifFalse: [false]]].	^collisions! !!BouncingAtomsMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:14'!defaultColor"answer the default color/fill style for the receiver"	^ Color		r: 0.8		g: 1.0		b: 0.8! !!BouncingAtomsMorph methodsFor: 'drawing' stamp: ''!drawOn: aCanvas	"Clear the damageReported flag when redrawn."	super drawOn: aCanvas.	damageReported := false.! !!BouncingAtomsMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:14'!initialize	"initialize the state of the receiver"	super initialize.	""	damageReported := false.	self extent: 400 @ 250.	infectionHistory := OrderedCollection new.	transmitInfection := false.	self addAtoms: 30! !!BouncingAtomsMorph methodsFor: 'initialization' stamp: 'ar 8/13/2003 11:41'!intoWorld: aWorld	"Make sure report damage at least once"	damageReported := false.	super intoWorld: aWorld.! !!BouncingAtomsMorph methodsFor: 'change reporting' stamp: 'ar 11/12/2000 18:42'!invalidRect: damageRect from: aMorph	"Try setting 'quickRedraw' to true. This invalidates the entire morph, whose bounds typically subsume all it's submorphs. (However, this code checks that assumption and passes through any damage reports for out-of-bounds submorphs. Note that atoms with super-high velocities do occaisionally shoot through the walls!!) An additional optimization is to only submit only damage report per display cycle by using the damageReported flag, which is reset to false when the morph is drawn."	| quickRedraw |	quickRedraw := true.  "false gives the original invalidRect: behavior"	(quickRedraw and:	 [(bounds origin <= damageRect topLeft) and:	 [damageRect bottomRight <= bounds corner]]) ifTrue: [		"can use quick redraw if damage is within my bounds"		damageReported ifFalse: [super invalidRect: bounds from: self].  "just report once"		damageReported := true.	] ifFalse: [super invalidRect: damageRect from: aMorph].  "ordinary damage report"! !!BouncingAtomsMorph methodsFor: 'menu' stamp: 'DamienCassou 9/29/2009 09:03'!setAtomCount	| countString count |	countString := UIManager default		request: 'Number of atoms?' translated		initialAnswer: self submorphCount printString.	countString isEmptyOrNil ifTrue: [^ self].	count := Integer readFrom: (ReadStream on: countString).	self removeAllMorphs.	self addAtoms: count.! !!BouncingAtomsMorph methodsFor: 'other' stamp: 'jm 6/28/1998 18:31'!showInfectionHistory: evt	"Place a graph of the infection history in the world."	| graph |	infectionHistory isEmpty ifTrue: [^ self].	graph := GraphMorph new data: infectionHistory.	graph extent: ((infectionHistory size + (2 * graph borderWidth) + 5)@(infectionHistory last max: 50)).	evt hand attachMorph: graph.! !!BouncingAtomsMorph methodsFor: 'menu' stamp: ''!startInfection	self submorphsDo: [:m | m infected: false].	self firstSubmorph infected: true.	infectionHistory := OrderedCollection new: 500.	transmitInfection := true.	self startStepping.! !!BouncingAtomsMorph methodsFor: 'stepping and presenter' stamp: 'sw 7/15/1999 07:32'!step	"Bounce those atoms!!"	| r bounces |	super step.	bounces := 0.	r := bounds origin corner: (bounds corner - (8@8)).	self submorphsDo: [ :m |		(m isMemberOf: AtomMorph) ifTrue: [			(m bounceIn: r) ifTrue: [bounces := bounces + 1]]].	"compute a 'temperature' that is proportional to the number of bounces	 divided by the circumference of the enclosing rectangle"	self updateTemperature: (10000.0 * bounces) / (r width + r height).	transmitInfection ifTrue: [self transmitInfection].! !!BouncingAtomsMorph methodsFor: 'testing' stamp: 'jm 6/28/1998 18:10'!stepTime	"As fast as possible."	^ 0! !!BouncingAtomsMorph methodsFor: 'other' stamp: 'jm 6/28/1998 18:20'!transmitInfection	| infected count |	self collisionPairs do: [:pair |		infected := false.		pair do: [:atom | atom infected ifTrue: [infected := true]].		infected			ifTrue: [pair do: [:atom | atom infected: true]]].	count := 0.	self submorphsDo: [:m | m infected ifTrue: [count := count + 1]].	infectionHistory addLast: count.	count = submorphs size ifTrue: [		transmitInfection := false.		self stopStepping].! !!BouncingAtomsMorph methodsFor: 'other' stamp: 'dgd 2/22/2003 13:36'!updateTemperature: currentTemperature 	"Record the current temperature, which is taken to be the number of atoms that have bounced in the last cycle. To avoid too much jitter in the reading, the last several readings are averaged."	recentTemperatures isNil 		ifTrue: 			[recentTemperatures := OrderedCollection new.			20 timesRepeat: [recentTemperatures add: 0]].	recentTemperatures removeLast.	recentTemperatures addFirst: currentTemperature.	temperature := recentTemperatures sum asFloat / recentTemperatures size! !BouncingAtomsMorph initialize!